{"ast":null,"code":"\"use strict\";\n\nfunction _interopDefault(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e.default : e;\n}\n\nfunction trimWrappers(e) {\n  return e.replace(/\\[\\[/g, \"\").replace(/\\]\\]/g, \"\").replace(/\\{\\{/g, \"\").replace(/\\}\\}/g, \"\").trim();\n}\n\nfunction trimOr(e) {\n  var t = e.indexOf(\"|\");\n  return -1 !== t ? e.substring(0, t) : e;\n}\n\nfunction getValue(e, t) {\n  if (!e) return null;\n  var r = e.trim().replace(/File:/, \"\").replace(/\\{\\{\\d+\\}\\}/g, \"\").replace(extraPropertyPattern, \"\").replace(endingPattern, \"\");\n  if (\"y\" === r || \"yes\" === r) return !0;\n  if (\"birthPlace\" == t) return e.trim();\n  var a = r.match(linksPattern);\n  return a ? a[0].split(linkSeparatorPattern).filter(function (e) {\n    return e;\n  }) : trimOr(trimWrappers(r));\n}\n\nfunction dataType(e) {\n  var t = e.globalPattern,\n      r = e.parsePattern,\n      a = e.parse,\n      n = e.variable,\n      l = e.name;\n  return function (e) {\n    var i = e.match(t);\n\n    if (!i) {\n      var s;\n      return s = {}, defineProperty(s, l, []), defineProperty(s, \"sourceAfter\", e), s;\n    }\n\n    var o = i.map(function (e) {\n      return a(e.match(r));\n    }),\n        u = i.reduce(function (e, t, r) {\n      return o[r] === DO_NOT_REPLACE ? e : e.replace(t, \"$\" + n + \"_\" + r);\n    }, e);\n    return {\n      data: defineProperty({}, l, o),\n      sourceAfter: u\n    };\n  };\n}\n\nfunction byDataHandler(e, t) {\n  var r = e.source,\n      a = e.context,\n      n = t(r),\n      l = n.data,\n      i = n.sourceAfter;\n  return {\n    context: Object.assign({}, a, l),\n    source: i\n  };\n}\n\nfunction extractData(e) {\n  return dataTypes$1.map(function (e) {\n    return e.handler;\n  }).reduce(byDataHandler, {\n    context: {},\n    source: e\n  });\n}\n\nfunction findPropertyList(e) {\n  var t = e.match(keyValueGlobalPattern);\n  return t ? t.map(function (e) {\n    var t = keyValuePattern.exec(e);\n    if (!t) return null;\n    var r = slicedToArray(t, 3),\n        a = r[1],\n        n = r[2],\n        l = camelCase(a.trim());\n    return {\n      key: l,\n      value: getValue(n, l)\n    };\n  }).filter(function (e) {\n    return e;\n  }) : [];\n}\n\nfunction fillVariables(e, t, r) {\n  var a = r.simplifyDataValues;\n  if (\"string\" != typeof e) return console.log(\"Warning: Something went wrong. Could not fill variables in: (\" + (void 0 === e ? \"undefined\" : _typeof(e)) + \") \" + JSON.stringify(e)), {};\n  var n = dataTypes$1.find(function (t) {\n    return e.match(t.pattern);\n  });\n\n  if (n) {\n    var l = n.pattern.exec(e),\n        i = slicedToArray(l, 2),\n        s = i[0],\n        o = i[1],\n        u = t[n.name][parseInt(o, 10)];\n    return a || \"string\" != typeof u ? u : e.replace(s, u);\n  }\n\n  return e;\n}\n\nfunction fillVariablesUntilDone(e, t, r) {\n  if (void 0 === e) return e;\n  if (e instanceof Date) return e;\n  if (\"number\" == typeof e) return e;\n  if (Array.isArray(e)) return e.map(function (e) {\n    return fillVariablesUntilDone(e, t, r);\n  });\n  if (\"object\" === (void 0 === e ? \"undefined\" : _typeof(e))) return Object.keys(e).reduce(function (a, n) {\n    return Object.assign(a, defineProperty({}, n, fillVariablesUntilDone(e[n], t, r)));\n  }, {});\n  var a = fillVariables(e, t, r);\n  return a === e ? e : fillVariablesUntilDone(a, t, r);\n}\n\nfunction handleSmallData(e, t, r) {\n  var a = r.simplifyDataValues;\n\n  if (\"string\" == typeof e && e.match(smallDataType.pattern)) {\n    var n = e.replace(smallDataType.pattern, \"\").replace(/,/, \"\").trim(),\n        l = smallDataType.pattern.exec(e),\n        i = slicedToArray(l, 2),\n        s = i[1],\n        o = t[smallDataType.name][parseInt(s, 10)],\n        u = {\n      primary: getVariableValue(n, t, {\n        simplifyDataValues: a\n      }),\n      secondary: getVariableValue(o, t, {\n        simplifyDataValues: a\n      })\n    };\n    return a ? u.primary : u;\n  }\n\n  return null;\n}\n\nfunction getVariableValue(e, t) {\n  var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n      a = r.simplifyDataValues,\n      n = void 0 === a || a,\n      l = handleSmallData(e, t, {\n    simplifyDataValues: n\n  });\n  return l || fillVariablesUntilDone(e, t, {\n    simplifyDataValues: n\n  });\n}\n\nfunction reduceVariable(e, t, r, a) {\n  if (null === t) return null;\n  if (\"boolean\" == typeof t) return t;\n  if (Array.isArray(t)) return t.map(function (e) {\n    return getVariableValue(e, r, a);\n  });\n\n  if (e.match(/areaTotal/) || e.match(/population/)) {\n    var n = numberParse(t);\n    if (!1 === n && (n = parseFloat(t, 10)), !isNaN(n)) return n;\n  }\n\n  if (e.match(/date/i)) {\n    var l = +new Date(t);\n    if (!isNaN(l)) return new Date(t);\n  }\n\n  var i = getVariableValue(t, r, a);\n  return Array.isArray(i) ? i.map(function (e) {\n    return getVariableValue(e, r, a);\n  }) : i;\n}\n\nfunction byVariableReduction(e, t) {\n  return function (r, a) {\n    var n = a.key,\n        l = a.value,\n        i = reduceVariable(n, l, e, t);\n    return \"\" === i || null === i ? r : Object.assign({}, r, defineProperty({}, n, i));\n  };\n}\n\nfunction extractProperties(e, t) {\n  var r = e.source,\n      a = e.context;\n  return findPropertyList(r).reduce(byVariableReduction(a, t), {});\n}\n\nfunction transformProperties(e) {\n  return Object.keys(e).reduce(function (t, r) {\n    var a = e[r],\n        n = r.match(blankNamePattern);\n\n    if (n) {\n      var l = n[1] || \"\",\n          i = e[\"blank\" + l + \"NameSec2\"],\n          s = e[\"blank\" + l + \"InfoSec2\"];\n      return \"string\" != typeof i ? t : Object.assign(t, defineProperty({}, camelCase(i), s));\n    }\n\n    return r.match(blankInfoPattern) ? t : Object.assign(t, defineProperty({}, r, a));\n  }, {});\n}\n\nfunction findOuterIndex(e) {\n  for (var t = [], r = 0; r < e.length - 1; r++) {\n    var a = e.substr(r, 2);\n\n    if (\"{{\" !== a) {\n      if (\"}}\" === a) {\n        t.pop();\n        if (0 === t.length) return r + 2;\n        r++;\n      }\n    } else t.push(r), r++;\n  }\n}\n\nfunction parse(e) {\n  var t = e.match(infoBoxStartPattern);\n  if (!t) return {\n    data: e,\n    sourceLeft: null\n  };\n  var r = t.index,\n      a = e.substring(r),\n      n = findOuterIndex(a);\n  if (!n) return {\n    data: e,\n    sourceLeft: null\n  };\n  var l = a.substring(0, n),\n      i = e.substring(n);\n  return {\n    data: l,\n    sourceLeft: !i.match(infoBoxStartPattern) ? null : i\n  };\n}\n\nfunction extractInfoboxes(e) {\n  for (var t = parse(e), r = [t.data]; t.sourceLeft;) {\n    t = parse(t.sourceLeft), r.push(t.data);\n  }\n\n  return r;\n}\n\nfunction cleanSource(e) {\n  return e.replace(/''/g, \"\").replace(/\\|display=inline/g, \"\").replace(/<br\\s?\\/?>/g, \",\").replace(/<ref(\\s\\w+=[^>]+)?>.*<\\/ref>/g, \"\").replace(/&minus;/g, \"-\").replace(/<sup>/g, \"^\").replace(/\\{\\{sfn\\|([^\\}\\}]+)\\}\\}/g, \"\").replace(/\\{\\{efn\\|([^\\}\\}]+)\\}\\}/g, \"\").replace(/âˆ’/g, \"-\").replace(/<\\/sup>/g, \"\").replace(/<ref(\\s\\w+=[^>]+)?\\s?\\/>/g, \"\").replace(/<!--([\\s\\S]*?)-->/g, \"\").replace(/&nbsp;/g, \" \").replace(\"|''See list''\", \"\");\n}\n\nfunction transformRowSpan(e) {\n  return e.map(transformCells).reduce(function (e, t, r) {\n    for (var a = 0 === r ? 0 : 1, n = 0; n < t.length; n++) {\n      e[n + a] || (e[n + a] = {}), t[n] && (e[n + a][t[n]] = 1);\n    }\n\n    return e;\n  }, []).map(function (e) {\n    return Object.keys(e).join(\",\");\n  }).join(\" || \");\n}\n\nfunction getMatches(e, t) {\n  for (var r = void 0, a = []; null !== (r = t.exec(e));) {\n    a.push({\n      value: r[1] && r[1].trim(),\n      start: r.index,\n      end: r.index + r[0].length\n    });\n  }\n\n  return a;\n}\n\nfunction parseTableData(e) {\n  var t = e.match(rowPattern$1);\n  return t ? t.map(function (e) {\n    var t = e.match(rowPatternSingle);\n    return slicedToArray(t, 2)[1].trim().split(\"|\").slice(1);\n  }) : [];\n}\n\nfunction getTables(e) {\n  var t = getMatches(e, tableStartPattern$1),\n      r = getMatches(e, tableEndPattern$1);\n  return t.map(function (t, a) {\n    var n = r[a];\n    if (!n) throw new Error(\"[Table Parsing] Failed to pair table\");\n    return {\n      rows: parseTableData(e.substring(t.end, n.start).trim().replace(/'''/g, \"\")),\n      start: t.start,\n      end: n.end\n    };\n  });\n}\n\nfunction last(e) {\n  return e.length ? e[e.length - 1] : void 0;\n}\n\nvar camelCase = _interopDefault(require(\"camelcase\")),\n    _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n  return typeof e;\n} : function (e) {\n  return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n},\n    defineProperty = function defineProperty(e, t, r) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = r, e;\n},\n    slicedToArray = function () {\n  function e(e, t) {\n    var r = [],\n        a = !0,\n        n = !1,\n        l = void 0;\n\n    try {\n      for (var i, s = e[Symbol.iterator](); !(a = (i = s.next()).done) && (r.push(i.value), !t || r.length !== t); a = !0) {\n        ;\n      }\n    } catch (e) {\n      n = !0, l = e;\n    } finally {\n      try {\n        !a && s.return && s.return();\n      } finally {\n        if (n) throw l;\n      }\n    }\n\n    return r;\n  }\n\n  return function (t, r) {\n    if (Array.isArray(t)) return t;\n    if (Symbol.iterator in Object(t)) return e(t, r);\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  };\n}(),\n    toConsumableArray = function toConsumableArray(e) {\n  if (Array.isArray(e)) {\n    for (var t = 0, r = Array(e.length); t < e.length; t++) {\n      r[t] = e[t];\n    }\n\n    return r;\n  }\n\n  return Array.from(e);\n},\n    smallGlobalPattern = /\\{\\{small\\|([^\\}\\}]+)\\}\\}/g,\n    smallPattern = /small\\|([^\\}\\}]+)\\}\\}/,\n    small = {\n  globalPattern: smallGlobalPattern,\n  parsePattern: smallPattern,\n  parse: function parse(e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"SMALL\",\n  name: \"smalls\"\n},\n    flagGlobalPattern = /\\{\\{flag\\|([^\\}\\}]+)\\}\\}/g,\n    flagPattern = /flag\\|([^\\}\\}]+)\\}\\}/,\n    flag = {\n  globalPattern: flagGlobalPattern,\n  parsePattern: flagPattern,\n  parse: function parse(e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"FLAG\",\n  name: \"flags\"\n},\n    coordsGlobalPattern = /\\{\\{coord\\|([^\\}\\}]+)\\}\\}/g,\n    coordsPattern = /coord\\|([^\\}\\}]+)\\}\\}/,\n    coords = {\n  globalPattern: coordsGlobalPattern,\n  parsePattern: coordsPattern,\n  parse: function parse(e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"COORD\",\n  name: \"coords\"\n},\n    globalPattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/g,\n    pattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/,\n    instances = {\n  globalPattern: globalPattern,\n  parsePattern: pattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 3),\n        r = t[1],\n        a = t[2];\n    return r || a;\n  },\n  variable: \"INSTANCE\",\n  name: \"instances\"\n},\n    extraPropertyPattern = /\\n?\\s?\\|\\s?\\w+$/,\n    endingPattern = /\\n\\}\\}$/,\n    linksPattern = /((\\$\\w+_\\d+)\\s*,?\\s*){2,}/g,\n    linkSeparatorPattern = /[,\\s?]/g,\n    listItemPrefixPattern = /^\\|\\s?/,\n    unbulletedListGlobalPattern = /\\{\\{(?:unbulleted list|ubl|ubt|ublist|unbullet)\\s?\\|([^\\}\\}]+)\\}\\}/g,\n    unbulletedListItemPattern = /\\|\\s*([^|}]+)/g,\n    unbulletedLists = {\n  globalPattern: unbulletedListGlobalPattern,\n  parsePattern: unbulletedListItemPattern,\n  parse: function parse(e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"UNBULLETED_LIST\",\n  name: \"unbulletedLists\"\n},\n    listItemPrefixPattern$1 = /^\\*\\s*/,\n    plainListGlobalPattern = /\\n(\\*\\s*[^*|]+)+/g,\n    plainListItemPattern = /\\*\\s*([^*|]+)/g,\n    unmarkedLists = {\n  globalPattern: plainListGlobalPattern,\n  parsePattern: plainListItemPattern,\n  parse: function parse(e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern$1, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"UNMARKED_LIST\",\n  name: \"unmarkedLists\"\n},\n    listItemPrefixPattern$2 = /^\\*\\s?/,\n    plainListGlobalPattern$1 = /\\{\\{f?p?P?l?a?i?n?t?list\\s?\\|([^\\}\\}]+)\\}\\}/g,\n    plainListItemPattern$1 = /\\*\\s*([^*}]+)/g,\n    plainLists = {\n  globalPattern: plainListGlobalPattern$1,\n  parsePattern: plainListItemPattern$1,\n  parse: function parse(e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern$2, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"PLAIN_LIST\",\n  name: \"plainLists\"\n},\n    marriageGlobalPattern = /\\{\\{Marriage\\|([^\\}\\}]+)\\}\\}/g,\n    marriagePattern = /Marriage\\|([^|]+)\\|(.*)\\}\\}/,\n    marriages = {\n  globalPattern: marriageGlobalPattern,\n  parsePattern: marriagePattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 3);\n    return {\n      who: t[1],\n      married: t[2]\n    };\n  },\n  variable: \"MARRIAGE\",\n  name: \"marriages\"\n},\n    otherGlobalPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/g,\n    otherPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/,\n    other = {\n  globalPattern: otherGlobalPattern,\n  parsePattern: otherPattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 4),\n        r = t[1];\n    t[2], t[3];\n    return r;\n  },\n  variable: \"OTHER\",\n  name: \"others\"\n},\n    birthDateGlobalPattern = /\\{\\{birth\\sdate([^\\}\\}]+)\\}\\}/gi,\n    birthDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)/,\n    millisInYear = 31536e6,\n    birthDates = {\n  globalPattern: birthDateGlobalPattern,\n  parsePattern: birthDatePattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 4),\n        r = t[1],\n        a = t[2],\n        n = t[3],\n        l = new Date(r, a - 1, n);\n    return {\n      date: l,\n      age: Math.floor((Date.now() - +l) / millisInYear)\n    };\n  },\n  variable: \"BIRTH_DATE\",\n  name: \"birthDates\"\n},\n    DO_NOT_REPLACE = Symbol(\"DO NOT REPLACE\"),\n    labeledDateGlobalPattern = /\\{\\{([^\\n\\}\\}]+)\\}\\}/g,\n    labeledDatePattern = /(.*)/,\n    labeledDates = {\n  globalPattern: labeledDateGlobalPattern,\n  parsePattern: labeledDatePattern,\n  parse: function parse(e) {\n    var t = e[0].indexOf(\"|\");\n\n    if (t > -1) {\n      var r = e[0].substring(t + 1).slice(0, -2),\n          a = new Date(r + \" GMT\");\n      if (!isNaN(a.getTime())) return {\n        date: a\n      };\n      if (a = new Date(r.split(\"|\").join(\"-\") + \" GMT\"), !isNaN(a.getTime())) return {\n        date: a\n      };\n    }\n\n    return DO_NOT_REPLACE;\n  },\n  variable: \"LABELED_DATE\",\n  name: \"labeledDates\"\n},\n    deathDateGlobalPattern = /\\{\\{death\\sdate\\sand\\sage([^\\}\\}]+)\\}\\}/gi,\n    deathDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|?(\\d+)?\\|?(\\d+)?/,\n    millisInYear$1 = 31536e6,\n    deathDates = {\n  globalPattern: deathDateGlobalPattern,\n  parsePattern: deathDatePattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 7),\n        r = t[1],\n        a = t[2],\n        n = t[3],\n        l = t[4],\n        i = t[5],\n        s = void 0 === i ? 0 : i,\n        o = t[6],\n        u = void 0 === o ? 0 : o,\n        c = new Date(r, a - 1, n),\n        f = new Date(l, s - 1, u);\n    return {\n      date: c,\n      age: Math.floor((Number(c) - Number(f)) / millisInYear$1)\n    };\n  },\n  variable: \"DEATH_DATE\",\n  name: \"deathDates\"\n},\n    URLGlobalPattern = /\\{\\{URL\\|([^\\}\\}]+)\\}\\}/g,\n    URLPattern = /URL\\|([^\\}\\}]+)\\}\\}/,\n    url = {\n  globalPattern: URLGlobalPattern,\n  parsePattern: URLPattern,\n  parse: function parse(e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"URL\",\n  name: \"urls\"\n},\n    websiteGlobalPattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)\\s+([\\w\\s]+)\\]/g,\n    websitePattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)\\s+([\\w\\s]+)\\]/,\n    website = {\n  globalPattern: websiteGlobalPattern,\n  parsePattern: websitePattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 5),\n        r = t[1],\n        a = t[2],\n        n = t[3];\n    return {\n      protocol: r,\n      hostname: a,\n      path: n,\n      title: t[4],\n      url: r + \"://\" + a + n\n    };\n  },\n  variable: \"WEBSITE\",\n  name: \"websites\"\n},\n    convertGlobalPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/g,\n    convertPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/,\n    convert = {\n  globalPattern: convertGlobalPattern,\n  parsePattern: convertPattern,\n  parse: function parse(e) {\n    var t = slicedToArray(e, 3);\n    return t[1] + \" \" + t[2];\n  },\n  variable: \"CONVERT\",\n  name: \"converts\"\n},\n    dataTypes = [instances, small, flag, coords, marriages, birthDates, labeledDates, deathDates, unbulletedLists, website, url, convert, other, plainLists, unmarkedLists],\n    dataTypes$1 = dataTypes.map(function (e) {\n  return {\n    handler: dataType(e),\n    name: e.name,\n    pattern: new RegExp(\"\\\\$\" + e.variable + \"_(\\\\d+)\")\n  };\n}),\n    keyValueGlobalPattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/g,\n    keyValuePattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/,\n    numberParse = function numberParse(e) {\n  return \"string\" == typeof e && (e = e.trim().replace(/ /g, \"\"), e.match(/,/) && e.match(/\\./) ? e.indexOf(\",\") < e.indexOf(\".\") ? parseEnglish(e) : parseSpanish(e) : e.match(/,/) && !e.match(/\\./) ? e.match(/,/g).length > 1 ? parseEnglish(e) : e.match(/,[0-9]{3}($|^[0-9])/) ? parseEnglish(e) : parseSpanish(e) : !e.match(/,/) && e.match(/\\./) ? e.match(/\\./g).length > 1 ? parseSpanish(e) : e.match(/\\.[0-9]{3}($|^[0-9])/) ? parseSpanish(e) : parseEnglish(e) : (+e).toString() === e && +e);\n},\n    parseEnglish = function parseEnglish(e) {\n  return +e.replace(/,/g, \"\");\n},\n    parseSpanish = function parseSpanish(e) {\n  return +e.replace(/\\./g, \"\").replace(/,/g, \".\");\n},\n    smallDataType = dataTypes$1.find(function (e) {\n  return \"smalls\" === e.name;\n}),\n    blankNamePattern = /blank(\\d+)?NameSec2/,\n    blankInfoPattern = /blank(\\d+)?InfoSec2/,\n    infoBoxStartPattern = /{{\\w*box/,\n    tableStartPattern = /{\\|(.*)\\n?/,\n    tableEndPattern = /\\n\\|}/,\n    headersPattern = /!\\s?(.*)/g,\n    rowPattern = /\\|-/,\n    cellSeparatorPattern = /(?:\\n\\|)|(?:\\|\\|)/,\n    linkPattern = /\\[\\[([^\\]]+)\\]\\]/g,\n    linkNamePattern = /^.*\\|/,\n    inlineHeaderPattern = \"!!\",\n    actionPattern = /{{anchor\\|(.*)}}/g,\n    ticks = /'''/g,\n    rowSpanCountPattern = /rowspan=\"(\\d+)\"/,\n    stripLinks = function stripLinks(e) {\n  return e.replace(linkPattern, function (e, t) {\n    return t.replace(linkNamePattern, \"\").trim() || t;\n  });\n},\n    removeActions = function removeActions(e) {\n  return e.replace(actionPattern, \"\");\n},\n    transformCell = function transformCell(e) {\n  return stripLinks(removeActions(e || \"\")).replace(rowSpanCountPattern, \"\").replace(linkNamePattern, \"\").replace(ticks, \"\").trim();\n},\n    transformCells = function transformCells(e) {\n  return e.split(cellSeparatorPattern).map(transformCell);\n},\n    findIndex = function findIndex(e, t) {\n  var r = e.match(t);\n  return r ? r.index : -1;\n},\n    findTableStart = function findTableStart(e) {\n  var t = e.match(tableStartPattern);\n  return t ? t.index + t[0].length : -1;\n},\n    findTableEnd = function findTableEnd(e) {\n  return findIndex(e, tableEndPattern);\n},\n    getHeaders = function getHeaders(e) {\n  for (var t = [], r = void 0; r = headersPattern.exec(e);) {\n    t.push.apply(t, toConsumableArray(r[1].split(inlineHeaderPattern).map(transformCell)));\n  }\n\n  return t;\n},\n    getRows = function getRows(e) {\n  var t = e.split(rowPattern).map(function (e) {\n    return e.replace(/^.*\\n+?\\|/, \"\").trim();\n  }).filter(function (e) {\n    return e;\n  }),\n      r = [],\n      a = 0,\n      n = 0,\n      l = [],\n      i = !0,\n      s = !1,\n      o = void 0;\n\n  try {\n    for (var u, c = t[Symbol.iterator](); !(i = (u = c.next()).done); i = !0) {\n      var f = u.value,\n          p = f.match(rowSpanCountPattern);\n      p && (a = 0, n = parseInt(p[1]), l = []), a < n ? (l.push(f), ++a === n && r.push(transformRowSpan(l))) : r.push(f);\n    }\n  } catch (e) {\n    s = !0, o = e;\n  } finally {\n    try {\n      !i && c.return && c.return();\n    } finally {\n      if (s) throw o;\n    }\n  }\n\n  return r;\n},\n    getNextTable = function getNextTable(e) {\n  var t = e,\n      r = findTableStart(t);\n  if (-1 === r) return null;\n  t = t.substring(r);\n  var a = findTableEnd(t);\n  if (-1 === a) return null;\n  t = t.substring(0, a);\n  var n = getRows(t);\n  if (!n.length) return null;\n  var l = getHeaders(n[0]);\n  return l.length ? {\n    data: n.slice(1).map(transformCells).map(function (e) {\n      return l.reduce(function (t, r, a) {\n        return t[camelCase(r)] = e[a], t;\n      }, {});\n    }),\n    end: r + a\n  } : null;\n},\n    parseTables = function parseTables(e) {\n  for (var t = [], r = e, a = null; a = getNextTable(r);) {\n    if (!a) return t;\n    t.push(a.data), r = r.substring(a.end);\n  }\n\n  return t;\n},\n    headingPattern = /[^=]==\\s?([\\w\\s]+)\\s?==/g,\n    subheadingPattern = /===([\\w\\s]+)===/g,\n    tableStartPattern$1 = /{{list.+start.*}}/gi,\n    tableEndPattern$1 = /{{list.+end.*}}/gi,\n    rowPattern$1 = /{{(.*)}}/g,\n    rowPatternSingle = /{{(.*)}}/,\n    parseLists = function parseLists(e) {\n  var t = getMatches(e, headingPattern),\n      r = getMatches(e, subheadingPattern),\n      a = getTables(e);\n  return a.forEach(function (e) {\n    var a = t.filter(function (t) {\n      return t.end < e.start;\n    }).map(function (e) {\n      return e.value;\n    });\n    e.heading = last(a);\n    var n = r.filter(function (t) {\n      return t.end < e.start;\n    }).map(function (e) {\n      return e.value;\n    });\n    e.subheading = last(n), delete e.start, delete e.end;\n  }), a;\n},\n    index = function index(e, t) {\n  var r = extractInfoboxes(e).map(function (e) {\n    return transformProperties(extractProperties(extractData(cleanSource(e)), t));\n  });\n  if (!r.length) return {};\n  var a = {\n    general: r.shift()\n  };\n  return r.forEach(function (e) {\n    var t = e.type;\n    t ? a[camelCase(t)] = e : Object.assign(a, {\n      general: Object.assign({}, a.general, e)\n    });\n  }), a.tables = parseTables(e), a.lists = parseLists(e), a;\n};\n\nmodule.exports = index;","map":null,"metadata":{},"sourceType":"script"}